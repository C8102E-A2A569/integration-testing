<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CodebuddyPersistentProjectState">
    <option name="autoFileSelection" value="true" />
    <option name="promptHistory">
      <list>
        <option value="Задание:&#10;Провести интеграционное тестирование программы на Java 21, осуществляющей вычисление системы функций.&#10;Мой вариант:&#10;x &lt;= 0 : (cos(x) + sin(x)) &#10;x &gt; 0 : (((((ln(x) * log_2(x)) ^ 3) / log_5(x)) - (log_10(x) * (log_5(x) ^ 3))) ^ 3)&#10;Правила выполнения работы: &#10;Все составляющие систему функции (как тригонометрические, так и логарифмические) должны быть выражены через базовые (тригонометрическая зависит от варианта; логарифмическая - натуральный логарифм). &#10;Структура приложения, тестируемого в рамках лабораторной работы, должна выглядеть как на картинке (пример приведён для базовой тригонометрической функции sin(x)):&#10;Обе &quot;базовые&quot; функции (в примере выше - sin(x) и ln(x)) должны быть реализованы при помощи разложения в ряд с задаваемой погрешностью. Использовать тригонометрические / логарифмические преобразования для упрощения функций ЗАПРЕЩЕНО. &#10;Для КАЖДОГО модуля должны быть реализованы табличные заглушки. При этом, необходимо найти область допустимых значений функций, и, при необходимости, определить взаимозависимые точки в модулях. &#10;Разработанное приложение должно позволять выводить значения, выдаваемое любым модулем системы, в сsv файл вида «X, Результаты модуля (X)», позволяющее произвольно менять шаг наращивания Х. Разделитель в файле csv можно использовать произвольный. &#10;Порядок выполнения работы:&#10;Разработать приложение, руководствуясь приведёнными выше правилами. &#10;С помощью JUNIT5 разработать тестовое покрытие системы функций, проведя анализ эквивалентности и учитывая особенности системы функций. Для анализа особенностей системы функций и составляющих ее частей можно использовать сайт https://www.wolframalpha.com/. &#10;Собрать приложение, состоящее из заглушек. Провести интеграцию приложения по 1 модулю, с обоснованием стратегии интеграции, проведением интеграционных тестов и контролем тестового покрытия системы функций.&#10;Отчёт по работе должен содержать: &#10;UML-диаграмму классов разработанного приложения. &#10;Описание тестового покрытия с обоснованием его выбора. &#10;Графики, построенные csv-выгрузкам, полученным в процессе интеграции приложения.&#10;&#10;Код уже написан. Осталось его протестировать. &#10;С чего мне начать тестировать и как? Все ли соответствует заданию? " />
        <option value="Объясни мне весь код на русском языке. Представь, что я студент, который будет защищать эту лабу преподавателю. Нужно, чтобы каждый класс имел логичное объяснение того, зачем он используется и почему именно так реализован. И в какой последовательности мне нужно начать показывать тестирование преподавателю(распиши по классам). &#10;Задание, по которому выполнялась лаба:&#10;Провести интеграционное тестирование программы на Java 21, осуществляющей вычисление системы функций.&#10;Мой вариант:&#10;x &lt;= 0 : (cos(x) + sin(x)) &#10;x &gt; 0 : (((((ln(x) * log_2(x)) ^ 3) / log_5(x)) - (log_10(x) * (log_5(x) ^ 3))) ^ 3)&#10;Правила выполнения работы: &#10;Все составляющие систему функции (как тригонометрические, так и логарифмические) должны быть выражены через базовые (тригонометрическая зависит от варианта; логарифмическая - натуральный логарифм). &#10;Структура приложения, тестируемого в рамках лабораторной работы, должна выглядеть как на картинке (пример приведён для базовой тригонометрической функции sin(x)):&#10;Обе &quot;базовые&quot; функции (в примере выше - sin(x) и ln(x)) должны быть реализованы при помощи разложения в ряд с задаваемой погрешностью. Использовать тригонометрические / логарифмические преобразования для упрощения функций ЗАПРЕЩЕНО. &#10;Для КАЖДОГО модуля должны быть реализованы табличные заглушки. При этом, необходимо найти область допустимых значений функций, и, при необходимости, определить взаимозависимые точки в модулях. &#10;Разработанное приложение должно позволять выводить значения, выдаваемое любым модулем системы, в сsv файл вида «X, Результаты модуля (X)», позволяющее произвольно менять шаг наращивания Х. Разделитель в файле csv можно использовать произвольный. &#10;Порядок выполнения работы:&#10;Разработать приложение, руководствуясь приведёнными выше правилами. &#10;С помощью JUNIT5 разработать тестовое покрытие системы функций, проведя анализ эквивалентности и учитывая особенности системы функций. Для анализа особенностей системы функций и составляющих ее частей можно использовать сайт https://www.wolframalpha.com/. &#10;Собрать приложение, состоящее из заглушек. Провести интеграцию приложения по 1 модулю, с обоснованием стратегии интеграции, проведением интеграционных тестов и контролем тестового покрытия системы функций.&#10;Отчёт по работе должен содержать: &#10;UML-диаграмму классов разработанного приложения. &#10;Описание тестового покрытия с обоснованием его выбора. &#10;Графики, построенные csv-выгрузкам, полученным в процессе интеграции приложения." />
        <option value="Почему не заполнился system_negative.csv? Из-за того, что логарифм не принимает отрицательные значения? Это вообще правильно? Так и должно работать? Вот мой вариант: x &lt;= 0 : (cos(x) + sin(x)) &#10;x &gt; 0 : (((((ln(x) * log_2(x)) ^ 3) / log_5(x)) - (log_10(x) * (log_5(x) ^ 3))) ^ 3)" />
        <option value="Дай описание тестового покрытия в моем проекте с обоснованием его выбора " />
        <option value="Проверь, использую ли я заглушки(mock) в интеграционных тестах? Мне кажется, что мои классы Mock это просто имитация mock, но не настоящие mock. " />
        <option value="Ты не удалил классы Mock и в классе IntegrationTestStrategy появились ошибки. " />
      </list>
    </option>
    <option name="selectedModel" value="codebuddy:DEEPSEEK_V3" />
    <option name="ttsEnabled" value="false" />
  </component>
</project>